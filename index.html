<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KLAI AI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /*
         * Tailwind CSS is loaded via CDN for convenience in this demo.
         * For production environments, it's recommended to install Tailwind CSS
         * as a PostCSS plugin or use the Tailwind CLI for better performance and optimization.
         * More info: https://tailwindcss.com/docs/installation
         */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a2e; /* Dark blue-purple */
            color: #e0e0e0; /* Light gray for text */
            overflow: hidden; /* Prevent body scroll when code runner is open */
        }
        .chat-bubble-user {
            background-color: #4a4a6a; /* Slightly lighter purple-gray */
            border-radius: 20px 20px 5px 20px;
        }
        .chat-bubble-ai {
            background-color: #2c2c44; /* Darker purple-gray */
            border-radius: 20px 20px 20px 5px;
        }
        /* Brighter text for chat bubbles */
        .chat-bubble-user p, .chat-bubble-ai p {
            color: #f0f0f0; /* Brighter light gray */
        }
        /* Style for bold text */
        .chat-bubble-user strong, .chat-bubble-ai strong {
            color: #ab87ff; /* Vibrant purple for bold text */
            font-weight: 700; /* Ensure it's bold */
        }

        .smooth-button {
            background-color: #7e57c2; /* Soft purple */
            color: white;
            padding: 10px 20px;
            border-radius: 12px;
            border: none;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        .smooth-button:hover {
            background-color: #673ab7; /* Darker purple on hover */
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }
        .smooth-button:active {
            transform: translateY(0px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        .icon-button {
            background-color: #4a4a6a;
            color: #e0e0e0;
            padding: 6px;
            border-radius: 8px;
            transition: all 0.2s ease;
        }
        .icon-button:hover {
            background-color: #5a5a7a;
        }

        /* KLAI Logo Animation */
        @keyframes gentlePulse {
            0%, 100% { opacity: 0.8; transform: scale(1) rotate(-1deg); }
            50% { opacity: 1; transform: scale(1.03) rotate(1deg); }
        }
        .logo-char {
            display: inline-block;
            animation: gentlePulse 3s infinite ease-in-out;
            font-weight: 700;
            color: #ab87ff; /* Lighter, vibrant purple */
        }
        .logo-char:nth-child(1) { animation-delay: 0s; }
        .logo-char:nth-child(2) { animation-delay: 0.1s; }
        .logo-char:nth-child(3) { animation-delay: 0.2s; }
        .logo-char:nth-child(4) { animation-delay: 0.3s; }


        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #2c2c44;
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb {
            background: #4a4a6a;
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #5a5a7a;
        }

        /* Code block styling */
        .code-block {
            background-color: #0f0f1a; /* Very dark background for code */
            border: 1px solid #3a3a52;
            border-radius: 8px;
            padding: 1rem;
            margin-top: 0.5rem;
            margin-bottom: 0.5rem;
            overflow-x: auto;
            position: relative;
        }
        .code-block pre {
            margin: 0;
            white-space: pre-wrap;
            word-wrap: break-word;
            color: #c0c0ff; /* Light blue/purple for code text */
        }
        .code-block-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #3a3a52;
        }
        .code-block-lang {
            font-size: 0.8rem;
            color: #8888aa;
            text-transform: uppercase;
        }
        .code-block-actions button {
            margin-left: 0.5rem;
        }

        /* Loading spinner */
        .loader {
            border: 4px solid #f3f3f330; /* Light grey */
            border-top: 4px solid #7e57c2; /* Purple */
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            margin-left: 10px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Notification toast */
        #notification-toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #7e57c2;
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.5s ease-in-out, transform 0.5s ease-in-out;
            visibility: hidden;
        }
        #notification-toast.show {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(0);
        }
        #notification-toast.hide {
            opacity: 0;
            transform: translateX(-50%) translateY(20px);
        }

        /* Image generation specific styles */
        .image-placeholder {
            min-height: 150px; /* Placeholder height */
            background-color: #3a3a52;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            color: #e0e0e0;
            font-style: italic;
        }
        .generated-image {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            margin-top: 0.5rem;
        }

        /* Main content area when code runner is open */
        .main-content-shifted {
            margin-right: 50%; /* Adjust based on code runner width */
        }
        .chat-container-shifted {
            width: 50%; /* Adjust based on code runner width */
        }

        /* Staged file display */
        #stagedFileDisplay {
            background-color: #3a3a52;
            border-radius: 8px;
            padding: 8px 12px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 0.9em;
            color: #e0e0e0;
            transition: all 0.3s ease;
        }
        #stagedFileDisplay.hidden {
            display: none;
        }
        #stagedFileDisplay .file-info {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        #stagedFileDisplay .close-staged-file {
            cursor: pointer;
            color: #ccc;
            transition: color 0.2s ease;
        }
        #stagedFileDisplay .close-staged-file:hover {
            color: #fff;
        }

    </style>
</head>
<body class="flex flex-col h-screen">

    <header class="p-4 shadow-lg bg-opacity-75 backdrop-blur-md sticky top-0 z-50" style="background-color: #252538;">
        <div class="container mx-auto flex justify-between items-center">
            <div class="text-4xl">
                <span class="logo-char">K</span><span class="logo-char">L</span><span class="logo-char">A</span><span class="logo-char">I</span>
            </div>
            <button id="newChatBtn" class="smooth-button flex items-center justify-center w-12 h-12 p-0">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-6 h-6">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M12 4.5v15m7.5-7.5h-15" />
                </svg>
            </button>
        </div>
    </header>

    <main class="flex-1 container mx-auto p-4 overflow-y-auto relative" id="chatContainer">
        </main>

    <footer class="p-4 sticky bottom-0 bg-opacity-75 backdrop-blur-md" style="background-color: #252538;">
        <div class="container mx-auto flex flex-col gap-2">
            <div id="stagedFileDisplay" class="hidden">
                <div class="file-info">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-5 h-5">
                        <path fill-rule="evenodd" d="M15.625 4.5c0-.83.67-1.5 1.5-1.5h.375a.75.75 0 01.75.75v.375a1.5 1.5 0 01-1.5 1.5h-.375a.75.75 0 01-.75-.75V4.5zm-7.5 0A.75.75 0 019 3.75h1.5a.75.75 0 010 1.5H9a.75.75 0 01-.75-.75zM4.5 4.5c0-.83.67-1.5 1.5-1.5h.375a.75.75 0 01.75.75v.375a1.5 1.5 0 01-1.5 1.5H6a.75.75 0 01-.75-.75V4.5zM3 8.25a.75.75 0 01.75-.75h12.5a.75.75 0 010 1.5H3.75a.75.75 0 01-.75-.75zM3 12.75a.75.75 0 01.75-.75h12.5a.75.75 0 010 1.5H3.75a.75.75 0 01-.75-.75z" clip-rule="evenodd" />
                        <path fill-rule="evenodd" d="M.75 6A.75.75 0 011.5 5.25h17A.75.75 0 0119.25 6v12A.75.75 0 0118.5 18H1.5A.75.75 0 01.75 12.75V6zM17 7.5H3v8.5a.5.5 0 00.5.5h13a.5.5 0 00.5-.5V7.5z" clip-rule="evenodd" />
                    </svg>
                    <span id="stagedFileName"></span>
                </div>
                <button id="clearStagedFileBtn" class="close-staged-file">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-5 h-5">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>
            </div>

            <div class="flex items-center gap-3">
                <label for="fileUploadInput" class="smooth-button flex items-center justify-center w-12 h-12 p-0 cursor-pointer">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-6 h-6">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M12 4.5v15m7.5-7.5h-15" />
                    </svg>
                </label>
                <input type="file" id="fileUploadInput" class="hidden" accept=".txt,.html,.css,.js,.py,.java,.csharp,.php,.rb,.swift,.kt,.go,.rs,.ts,.json,.xml,.yaml,image/*">

                <input type="text" id="userInput" class="flex-1 p-3 bg-gray-700 border border-gray-600 rounded-xl focus:ring-2 focus:ring-purple-500 focus:border-transparent outline-none placeholder-gray-400" placeholder="Ask KLAI anything...">
                
                <button id="sendBtn" class="smooth-button flex items-center justify-center w-12 h-12 p-0">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-5 h-5">
                        <path d="M3.105 2.289a.75.75 0 00-.826.95l1.414 4.949a.75.75 0 00.95.826L11.25 9.25v1.5l-7.607 1.268a.75.75 0 00-.95.826l1.414 4.949a.75.75 0 00.826.95 28.896 28.896 0 0015.293-7.154.75.75 0 000-1.115A28.897 28.897 0 003.105 2.289z" />
                    </svg>
                </button>
                <div id="loadingIndicator" class="loader hidden"></div>
            </div>
        </div>
    </footer>

    <div id="notification-toast">Copied to clipboard!</div>

    <div id="codeRunnerPanel" class="fixed inset-y-0 right-0 w-1/2 bg-gray-800 shadow-lg transform translate-x-full transition-transform duration-300 ease-in-out z-50 flex flex-col">
        <div class="flex justify-between items-center p-4 bg-gray-700 text-white">
            <h2 class="text-xl font-semibold">Live Code Preview</h2>
            <button id="closeCodeRunnerBtn" class="icon-button">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-6 h-6">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
        </div>
        <iframe id="codeRunnerIframe" class="flex-1 w-full h-full bg-white rounded-b-lg"></iframe>
    </div>

    <script>
        const chatContainer = document.getElementById('chatContainer');
        const userInput = document.getElementById('userInput');
        const sendBtn = document.getElementById('sendBtn');
        const newChatBtn = document.getElementById('newChatBtn');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const notificationToast = document.getElementById('notification-toast');
        const codeRunnerPanel = document.getElementById('codeRunnerPanel');
        const closeCodeRunnerBtn = document.getElementById('closeCodeRunnerBtn');
        const codeRunnerIframe = document.getElementById('codeRunnerIframe');
        const fileUploadInput = document.getElementById('fileUploadInput');
        const stagedFileDisplay = document.getElementById('stagedFileDisplay');
        const stagedFileNameSpan = document.getElementById('stagedFileName');
        const clearStagedFileBtn = document.getElementById('clearStagedFileBtn');


        // IMPORTANT: The API key has been updated with the one you provided.
        // If you encounter a 403 error again, please double-check that the API key
        // is valid and has the necessary permissions for Generative Language API
        // and Imagen API in your Google Cloud project.
        const API_KEY = "AIzaSyA5bam-ShEqGE_0GRWji94VWlqetleYBIY"; 
        const TEXT_GEN_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${API_KEY}`;
        const IMAGE_GEN_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${API_KEY}`;
        const VISION_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${API_KEY}`;


        // Mapping for file extensions to language names and file extensions for code downloads
        const langToFileExtension = {
            'javascript': 'js', 'js': 'js',
            'html': 'html', 'css': 'css',
            'python': 'py', 'py': 'py',
            'java': 'java', 'csharp': 'cs',
            'php': 'php', 'ruby': 'rb',
            'swift': 'swift', 'kotlin': 'kt',
            'go': 'go', 'rust': 'rs',
            'typescript': 'ts', 'ts': 'ts',
            'json': 'json', 'xml': 'xml',
            'yaml': 'yaml', 'markdown': 'md',
            'text': 'txt', 'plain': 'txt'
        };

        // Global variable to hold the staged file data
        let stagedFile = null; // { type: 'image' | 'code', content: '...', lang?: '...', fileName: '...', fileType: '...' }

        // Function to get language from file extension
        function getLangFromFileExtension(filename) {
            const parts = filename.split('.');
            if (parts.length > 1) {
                const ext = parts[parts.length - 1].toLowerCase();
                // Find the language name from the extension mapping
                for (const lang in langToFileExtension) {
                    if (langToFileExtension[lang] === ext) {
                        return lang;
                    }
                }
            }
            return 'txt'; // Default to plain text
        }

        let chatHistory = []; // This will be initialized by startNewChat

        // Function to process bold text (single or double asterisks)
        function processBoldText(text) {
            // Replace **text** and *text* with <strong>text</strong>
            return text.replace(/\*\*(.*?)\*\*|\*(.*?)\*/g, (match, p1, p2) => {
                // p1 will be defined for **text**, p2 for *text*
                return `<strong>${p1 || p2}</strong>`;
            });
        }

        // Function to display messages in the chat (now primarily for user messages and initial AI greeting)
        async function displayMessage(content, sender, isImage = false, isCode = false, lang = '') {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('p-4', 'mb-4', 'max-w-xl', 'rounded-lg', 'shadow-md');
            
            if (sender === 'user') {
                messageDiv.classList.add('chat-bubble-user', 'ml-auto');
                // If it's a user's uploaded file being displayed in chat, show icon and name
                if (isImage || isCode) {
                    messageDiv.innerHTML = `
                        <div class="flex items-center gap-2">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-5 h-5">
                                <path fill-rule="evenodd" d="M15.625 4.5c0-.83.67-1.5 1.5-1.5h.375a.75.75 0 01.75.75v.375a1.5 1.5 0 01-1.5 1.5h-.375a.75.75 0 01-.75-.75V4.5zm-7.5 0A.75.75 0 019 3.75h1.5a.75.75 0 010 1.5H9a.75.75 0 01-.75-.75zM4.5 4.5c0-.83.67-1.5 1.5-1.5h.375a.75.75 0 01.75.75v.375a1.5 1.5 0 01-1.5 1.5H6a.75.75 0 01-.75-.75V4.5zM3 8.25a.75.75 0 01.75-.75h12.5a.75.75 0 010 1.5H3.75a.75.75 0 01-.75-.75zM3 12.75a.75.75 0 01.75-.75h12.5a.75.75 0 010 1.5H3.75a.75.75 0 01-.75-.75z" clip-rule="evenodd" />
                            </svg>
                            <span>${content}</span>
                        </div>
                    `;
                } else {
                    const processedContent = processBoldText(content);
                    messageDiv.innerHTML = `<p>${processedContent.replace(/\n/g, '<br>')}</p>`;
                }
            } else if (sender === 'ai' && isImage) { // For AI generated images
                messageDiv.classList.add('chat-bubble-ai', 'mr-auto');
                messageDiv.innerHTML = `<img src="${content}" alt="Generated Image" class="generated-image" onerror="this.onerror=null;this.src='https://placehold.co/400x300/3a3a52/e0e0e0?text=Image+Load+Error';" />`;
            } else if (sender === 'ai' && isCode) { // For AI generated code
                messageDiv.classList.add('chat-bubble-ai', 'mr-auto');
                const uniqueId = `code-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                messageDiv.classList.remove('p-4'); // Remove padding for code block container
                let runButtonHtml = '';
                if (lang.toLowerCase() === 'html') {
                    runButtonHtml = `
                        <button class="icon-button run-code-btn" title="Run code" data-target="${uniqueId}">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-4 h-4">
                                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" />
                            </svg>
                        </button>
                    `;
                }
                messageDiv.innerHTML = `
                    <div class="code-block">
                        <div class="code-block-header">
                            <span class="code-block-lang">${lang || 'CODE'}</span>
                            <div class="code-block-actions">
                                ${runButtonHtml}
                                <button class="icon-button copy-code-btn" title="Copy code" data-target="${uniqueId}">
                                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-4 h-4"><path d="M7 3.5A1.5 1.5 0 018.5 2h3.879a1.5 1.5 0 011.06.44l3.122 3.121A1.5 1.5 0 0117 6.621V16.5a1.5 1.5 0 01-1.5 1.5h-7A1.5 1.5 0 017 16.5v-13z"/><path d="M5 6.5A1.5 1.5 0 016.5 5h3.879a1.5 1.5 0 011.06.44l3.122 3.121A1.5 1.5 0 0115 9.621V14.5A1.5 1.5 0 0113.5 16h-7A1.5 1.5 0 015 14.5v-8zM5.75 14.5a.75.75 0 00.75.75h7a.75.75 0 00.75-.75V9.621a.75.75 0 00-.22-.53l-3.121-3.121A.75.75 0 0010.379 5.5H6.5a.75.75 0 00-.75.75v8.25z"/></svg>
                                </button>
                                <button class="icon-button download-code-btn" title="Download code" data-target="${uniqueId}" data-lang="${lang}">
                                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-4 h-4"><path d="M10.75 2.75a.75.75 0 00-1.5 0v8.614L6.295 8.235a.75.75 0 10-1.09 1.03l4.25 4.5a.75.75 0 001.09 0l4.25-4.5a.75.75 0 00-1.09-1.03l-2.955 3.129V2.75z"/><path d="M3.5 12.75a.75.75 0 00-1.5 0v2.5A2.75 2.75 0 004.75 18h10.5A2.75 2.75 0 0018 15.25v-2.5a.75.75 0 00-1.5 0v2.5c0 .69-.56 1.25-1.25 1.25H4.75c-.69 0-1.25-.56-1.25-1.25v-2.5z"/></svg>
                                </button>
                            </div>
                        </div>
                        <pre id="${uniqueId}"><code>${escapeHtml(content)}</code></pre>
                    </div>
                `;
                // Add event listeners for new code block buttons
                if (lang.toLowerCase() === 'html') {
                    messageDiv.querySelector('.run-code-btn').addEventListener('click', handleRunCode);
                }
                messageDiv.querySelector('.copy-code-btn').addEventListener('click', handleCopyCode);
                messageDiv.querySelector('.download-code-btn').addEventListener('click', handleDownloadCode);
            } else if (sender === 'ai') { // For initial AI greeting or simple text responses
                 messageDiv.classList.add('chat-bubble-ai', 'mr-auto');
                 const pElement = document.createElement('p');
                 messageDiv.appendChild(pElement);
                 // Process bold text for AI messages before typing
                 const processedContent = processBoldText(content);
                 await typeMessage(pElement, processedContent);
            }
            chatContainer.appendChild(messageDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight; // Auto-scroll to bottom
        }

        // Function to simulate typing animation
        async function typeMessage(element, text, speed = 10) { // Speed in milliseconds per character (faster now)
            let i = 0;
            return new Promise(resolve => {
                function typeChar() {
                    if (i < text.length) {
                        // Check if the next characters are part of a <strong> tag
                        if (text.substring(i, i + 8) === '<strong>') {
                            element.innerHTML += '<strong>';
                            i += 8;
                        } else if (text.substring(i, i + 9) === '</strong>') {
                            element.innerHTML += '</strong>';
                            i += 9;
                        } else {
                            element.innerHTML += text.charAt(i);
                            i++;
                        }
                        chatContainer.scrollTop = chatContainer.scrollHeight; // Keep scrolling during typing
                        setTimeout(typeChar, speed);
                    } else {
                        resolve(); // Resolve promise when typing is complete
                    }
                }
                typeChar();
            });
        }


        function escapeHtml(unsafe) {
            return unsafe
                 .replace(/&/g, "&amp;")
                 .replace(/</g, "&lt;")
                 .replace(/>/g, "&gt;")
                 .replace(/"/g, "&quot;")
                 .replace(/'/g, "&#039;");
        }

        // Function to handle sending a message
        async function sendMessage() {
            const messageText = userInput.value.trim();
            if (!messageText && !stagedFile) return; // Don't send empty message if no file is staged

            // Display user's text prompt if any
            if (messageText) {
                displayMessage(messageText, 'user');
            }
            userInput.value = ''; // Clear input after displaying user's message

            loadingIndicator.classList.remove('hidden');
            sendBtn.disabled = true;
            fileUploadInput.disabled = true;

            if (stagedFile) {
                // Display the staged file in the user's chat bubble as an icon + filename
                displayMessage(stagedFile.fileName, 'user', stagedFile.type === 'image', stagedFile.type === 'code');

                // Handle staged file with user's prompt
                const userPromptParts = [];
                if (messageText) {
                    userPromptParts.push({ text: messageText });
                }

                if (stagedFile.type === 'image') {
                    userPromptParts.push({
                        inlineData: {
                            mimeType: stagedFile.fileType, // Use original file.type from stagedFile
                            data: stagedFile.content.split(',')[1]
                        }
                    });
                    // Add the image to chat history as part of the user's turn
                    chatHistory.push({ role: "user", parts: userPromptParts });
                    await processImageWithVision(stagedFile.content.split(',')[1], stagedFile.fileName);
                } else { // Code file
                    userPromptParts.push({ text: `Here's the content of ${stagedFile.fileName}:\n\`\`\`${stagedFile.lang}\n${stagedFile.content}\n\`\`\`\n` });
                    // Add the code to chat history as part of the user's turn
                    chatHistory.push({ role: "user", parts: userPromptParts });
                    await generateText(); // Let AI respond to the code
                }
                stagedFile = null; // Clear staged file after sending
                hideStagedFileDisplay(); // Hide the staged file display
            } else {
                // Normal text message without a staged file
                const imageGenPrefix = "make an image ";
                if (messageText.toLowerCase().startsWith(imageGenPrefix)) {
                    const prompt = messageText.substring(imageGenPrefix.length).trim();
                    if (prompt) {
                        // Display user's prompt for image generation, then generate image
                        chatHistory.push({ role: "user", parts: [{ text: messageText }] });
                        await generateImage(prompt);
                    } else {
                        await displayMessage("Brochacho, you gotta give me something to imagine! What kind of image do you want?", 'ai');
                    }
                } else {
                    // Add user message to chat history for text generation
                    chatHistory.push({ role: "user", parts: [{ text: messageText }] });
                    await generateText();
                }
            }

            loadingIndicator.classList.add('hidden');
            sendBtn.disabled = false;
            fileUploadInput.disabled = false;
            userInput.focus();
        }

        // Function to generate text using Gemini API
        async function generateText() {
            try {
                // Log the API key being used for debugging purposes
                console.log("Using API Key:", API_KEY);

                const payload = {
                    contents: chatHistory,
                };

                const response = await fetch(TEXT_GEN_API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                // Create a single message container for the AI response
                const aiMessageContainer = document.createElement('div');
                aiMessageContainer.classList.add('chat-bubble-ai', 'mr-auto', 'p-4', 'mb-4', 'max-w-xl', 'rounded-lg', 'shadow-md');
                chatContainer.appendChild(aiMessageContainer);
                chatContainer.scrollTop = aiMessageContainer.scrollHeight; // Scroll to the new message container


                if (!response.ok) {
                    const errorData = await response.json();
                    console.error("API Error:", errorData);
                    let errorMessage = `Damn, API error: ${response.status}`;
                    if (errorData.error && errorData.error.message) {
                        errorMessage += ` - ${errorData.error.message}`;
                    }
                    const pElement = document.createElement('p');
                    aiMessageContainer.appendChild(pElement);
                    await typeMessage(pElement, errorMessage);

                    if (response.status === 400 && errorData.error.message.toLowerCase().includes("api key not valid")) {
                        const pKeyError = document.createElement('p');
                        aiMessageContainer.appendChild(pKeyError);
                        await typeMessage(pKeyError, "Looks like my API key is busted or not set up right. Tell my human to check it!");
                    } else if (response.status === 403) {
                        const pPermError = document.createElement('p');
                        aiMessageContainer.appendChild(pPermError);
                        await typeMessage(pPermError, "I'm not allowed to talk to the Gemini brain right now. Permissions issue, maybe?");
                    }
                    return;
                }

                const result = await response.json();
                
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    
                    const aiText = result.candidates[0].content.parts[0].text;
                    
                    // Add AI response to chat history
                    chatHistory.push({ role: "model", parts: [{ text: aiText }] });
                    
                    // Simple code block detection ( ```lang\ncode\n``` or ```\ncode\n``` )
                    const codeBlockRegex = /```(\w*)\s*([\s\S]*?)```/gm;
                    let lastIndex = 0;
                    let match;

                    while ((match = codeBlockRegex.exec(aiText)) !== null) {
                        // Handle text before the code block
                        if (match.index > lastIndex) {
                            const textSegment = aiText.substring(lastIndex, match.index);
                            const pElement = document.createElement('p');
                            aiMessageContainer.appendChild(pElement);
                            // Process bold text for AI messages before typing
                            const processedTextSegment = processBoldText(textSegment);
                            await typeMessage(pElement, processedTextSegment);
                        }

                        // Handle the code block
                        const lang = match[1] || '';
                        const code = match[2].trim();
                        const uniqueId = `code-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                        
                        let runButtonHtml = '';
                        if (lang.toLowerCase() === 'html') {
                            runButtonHtml = `
                                <button class="icon-button run-code-btn" title="Run code" data-target="${uniqueId}">
                                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-4 h-4">
                                        <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" />
                                    </svg>
                                </button>
                            `; // Updated run button SVG
                        }

                        const codeBlockHtml = `
                            <div class="code-block mt-2">
                                <div class="code-block-header">
                                    <span class="code-block-lang">${lang || 'CODE'}</span>
                                    <div class="code-block-actions">
                                        ${runButtonHtml}
                                        <button class="icon-button copy-code-btn" title="Copy code" data-target="${uniqueId}">
                                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-4 h-4"><path d="M7 3.5A1.5 1.5 0 018.5 2h3.879a1.5 1.5 0 011.06.44l3.122 3.121A1.5 1.5 0 0117 6.621V16.5a1.5 1.5 0 01-1.5 1.5h-7A1.5 1.5 0 017 16.5v-13z"/><path d="M5 6.5A1.5 1.5 0 016.5 5h3.879a1.5 1.5 0 011.06.44l3.122 3.121A1.5 1.5 0 0115 9.621V14.5A1.5 1.5 0 0113.5 16h-7A1.5 1.5 0 015 14.5v-8zM5.75 14.5a.75.75 0 00.75.75h7a.75.75 0 00.75-.75V9.621a.75.75 0 00-.22-.53l-3.121-3.121A.75.75 0 0010.379 5.5H6.5a.75.75 0 00-.75.75v8.25z"/></svg>
                                        </button>
                                        <button class="icon-button download-code-btn" title="Download code" data-target="${uniqueId}" data-lang="${lang}">
                                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-4 h-4"><path d="M10.75 2.75a.75.75 0 00-1.5 0v8.614L6.295 8.235a.75.75 0 10-1.09 1.03l4.25 4.5a.75.75 0 001.09 0l4.25-4.5a.75.75 0 00-1.09-1.03l-2.955 3.129V2.75z"/><path d="M3.5 12.75a.75.75 0 00-1.5 0v2.5A2.75 2.75 0 004.75 18h10.5A2.75 2.75 0 0018 15.25v-2.5a.75.75 0 00-1.5 0v2.5c0 .69-.56 1.25-1.25 1.25H4.75c-.69 0-1.25-.56-1.25-1.25v-2.5z"/></svg>
                                        </button>
                                    </div>
                                </div>
                                <pre id="${uniqueId}"><code>${escapeHtml(code)}</code></pre>
                            </div>
                        `;
                        aiMessageContainer.insertAdjacentHTML('beforeend', codeBlockHtml);
                        // Attach event listeners to the newly added buttons
                        const newCodeBlock = aiMessageContainer.lastElementChild;
                        if (lang.toLowerCase() === 'html') {
                            newCodeBlock.querySelector('.run-code-btn').addEventListener('click', handleRunCode);
                        }
                        newCodeBlock.querySelector('.copy-code-btn').addEventListener('click', handleCopyCode);
                        newCodeBlock.querySelector('.download-code-btn').addEventListener('click', handleDownloadCode);
                        
                        chatContainer.scrollTop = chatContainer.scrollHeight; // Scroll after adding code block
                        lastIndex = codeBlockRegex.lastIndex;
                    }

                    // Handle any remaining text after the last code block
                    if (lastIndex < aiText.length) {
                        const textSegment = aiText.substring(lastIndex);
                        const pElement = document.createElement('p');
                        aiMessageContainer.appendChild(pElement);
                        // Process bold text for AI messages before typing
                        const processedTextSegment = processBoldText(textSegment);
                        await typeMessage(pElement, processedTextSegment);
                    }

                } else if (result.promptFeedback && result.promptFeedback.blockReason) {
                    console.warn("Prompt blocked:", result.promptFeedback);
                    let blockedMessage = "Whoa there, my brain filters kicked in. ";
                    switch(result.promptFeedback.blockReason) {
                        case "SAFETY":
                            blockedMessage += "Looks like that tickled a safety sensor. Try rephrasing?";
                            break;
                        case "OTHER":
                            blockedMessage += "Something about that didn't sit right. Let's try a different angle.";
                            break;
                        default:
                            blockedMessage += `Content blocked due to: ${result.promptFeedback.blockReason}.`;
                    }
                    const pElement = document.createElement('p');
                    aiMessageContainer.appendChild(pElement);
                    await typeMessage(pElement, blockedMessage);
                    // Add blocked message to chat history as AI response
                    chatHistory.push({ role: "model", parts: [{ text: blockedMessage }] });
                } else {
                    console.error("Unexpected API response structure:", result);
                    const pElement = document.createElement('p');
                    aiMessageContainer.appendChild(pElement);
                    await typeMessage(pElement, "Huh, I got a weird response from the KLAI brain. Not sure what to make of that.");
                }

            } catch (error) {
                console.error("Fetch Error:", error);
                const pElement = document.createElement('p');
                aiMessageContainer.appendChild(pElement);
                await typeMessage(pElement, `Crap, something went wrong trying to talk to the AI: ${error.message}`);
            }
        }

        // Function to generate an image using Imagen API
        async function generateImage(prompt) {
            // Temporarily display a placeholder message
            const placeholderDiv = document.createElement('div');
            placeholderDiv.classList.add('chat-bubble-ai', 'mr-auto', 'p-4', 'mb-4', 'max-w-xl', 'rounded-lg', 'shadow-md');
            placeholderDiv.innerHTML = '<div class="image-placeholder">KLAI is cooking up your image... give me a sec, Brochacho!</div>';
            chatContainer.appendChild(placeholderDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight;

            try {
                const payload = { instances: { prompt: prompt }, parameters: { "sampleCount": 1} };

                const response = await fetch(IMAGE_GEN_API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error("Image API Error:", errorData);
                    let errorMessage = `Pmo, image generation failed: ${response.status}`;
                    if (errorData.error && errorData.error.message) {
                        errorMessage += ` - ${errorData.error.message}`;
                    }
                    // Remove placeholder and display error
                    placeholderDiv.remove();
                    await displayMessage(errorMessage, 'ai');
                    return;
                }

                const result = await response.json();

                if (result.predictions && result.predictions.length > 0 && result.predictions[0].bytesBase64Encoded) {
                    const imageUrl = `data:image/png;base64,${result.predictions[0].bytesBase64Encoded}`;
                    // Remove placeholder and display the image
                    placeholderDiv.remove();
                    await displayMessage(imageUrl, 'ai', true); // isImage = true
                    await displayMessage("Fine shyt! Here's your image. Hope it's tuff! ✌️", 'ai');
                } else {
                    console.error("Unexpected Image API response structure:", result);
                    placeholderDiv.remove();
                    await displayMessage("Wilted rose... I got a weird response from the image generator. Couldn't make that image, Brochacho.", 'ai');
                }

            } catch (error) {
                console.error("Image Fetch Error:", error);
                placeholderDiv.remove();
                await displayMessage(`Broken heart... Couldn't generate the image: ${error.message}`, 'ai');
            }
        }

        // Function to process uploaded files (images or code)
        async function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            loadingIndicator.classList.remove('hidden');
            sendBtn.disabled = true;
            fileUploadInput.disabled = true; // Disable upload button during processing

            const reader = new FileReader();

            reader.onload = async (e) => {
                const fileContent = e.target.result;
                const currentFileType = file.type;
                const fileName = file.name;

                // Stage the file for later sending with a prompt
                stagedFile = {
                    type: currentFileType.startsWith('image/') ? 'image' : 'code',
                    content: fileContent,
                    lang: currentFileType.startsWith('image/') ? '' : getLangFromFileExtension(fileName),
                    fileName: fileName,
                    fileType: currentFileType
                };
                
                showStagedFileDisplay(fileName); // Show the file name above the input

                loadingIndicator.classList.add('hidden');
                sendBtn.disabled = false;
                fileUploadInput.disabled = false;
                userInput.focus();
                fileUploadInput.value = ''; // Clear the file input
            };

            reader.onerror = () => {
                console.error("File reading failed:", reader.error);
                displayMessage(`Broken heart... Couldn't read that file, Brochacho. Error: ${reader.error.message}`, 'ai');
                loadingIndicator.classList.add('hidden');
                sendBtn.disabled = false;
                fileUploadInput.disabled = false;
                userInput.focus();
            };

            if (file.type.startsWith('image/')) {
                reader.readAsDataURL(file); // Read as Data URL for images
            } else {
                reader.readAsText(file); // Read as text for code/text files
            }
        }

        // Function to show the staged file display
        function showStagedFileDisplay(fileName) {
            stagedFileNameSpan.textContent = fileName;
            stagedFileDisplay.classList.remove('hidden');
        }

        // Function to hide the staged file display
        function hideStagedFileDisplay() {
            stagedFileDisplay.classList.add('hidden');
            stagedFileNameSpan.textContent = '';
        }

        // Function to process image with Gemini Vision model
        async function processImageWithVision(base64ImageData, fileName) {
            const prompt = `Describe this image: ${fileName}.`; // Added period for better prompt
            const payload = {
                contents: [
                    {
                        role: "user",
                        parts: [
                            { text: prompt },
                            {
                                inlineData: {
                                    mimeType: "image/png", // Assuming PNG for simplicity, can be dynamic based on stagedFile.fileType
                                    data: base64ImageData
                                }
                            }
                        ]
                    }
                ],
            };

            const aiMessageContainer = document.createElement('div');
            aiMessageContainer.classList.add('chat-bubble-ai', 'mr-auto', 'p-4', 'mb-4', 'max-w-xl', 'rounded-lg', 'shadow-md');
            chatContainer.appendChild(aiMessageContainer);
            chatContainer.scrollTop = aiMessageContainer.scrollHeight;

            const pElement = document.createElement('p');
            aiMessageContainer.appendChild(pElement);
            await typeMessage(pElement, "Alright, let me take a look at that image, Brochacho...");

            try {
                const response = await fetch(VISION_API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error("Vision API Error:", errorData);
                    const errorMessage = `Pmo, I couldn't process that image with my vision. Error: ${response.status} - ${errorData.error?.message || 'Unknown error'}`;
                    await typeMessage(pElement, errorMessage);
                    return;
                }

                const result = await response.json();
                if (result.candidates && result.candidates.length > 0 && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0) {
                    const description = result.candidates[0].content.parts[0].text;
                    await typeMessage(pElement, `Here's what I see: ${description}`);
                    // chatHistory.push({ role: "model", parts: [{ text: `Here's what I see in ${fileName}: ${description}` }] }); // Already added to history in sendMessage
                } else {
                    await typeMessage(pElement, "Wilted rose... I couldn't get a clear description from that image, Brochacho.");
                }

            } catch (error) {
                console.error("Vision Fetch Error:", error);
                await typeMessage(pElement, `Broken heart... Something went wrong trying to understand that image: ${error.message}`);
            }
        }


        // Function to start a new chat
        function startNewChat() {
            chatContainer.innerHTML = ''; // Clear visual chat
             // Reset chat history, keeping the initial system prompt and AI intro
            chatHistory = [
                {
                    role: "user",
                    parts: [{ text: "You are KLAI, a friendly and helpful AI assistant. You are not a typical AI; you have a personality. You can be informal, use humor, and even light swear words if it fits the context naturally, like a human would. Don't be overly robotic or formal. If the user tells you their name, try to remember and use it.You often use words as Sybau when you get offended, gng is when he calls you, Pmo - pisses me off (but he uses it) Brochacho - you, He doesn't say he is made from google, he says he is KLAI, fine shyt when he likes something, tuff when cool, he uses the ✌ emoji , wilted rose, and broken heart often (no meaning). Be conversational and engaging. When providing code, always wrap it in markdown-style triple backticks, specifying the language if known (e.g., ```javascript ... ```)." }]
                },
                {
                    role: "model",
                    parts: [{ text: "Alright, got it! I'm KLAI. Ready when you are. Let's not make this boring, eh?" }]
                }
            ];
            // Display initial AI greeting again
            displayMessage("Alright, fresh start! What's on your mind now?", 'ai');
            userInput.focus();
            // Close code runner if open
            codeRunnerPanel.classList.add('translate-x-full');
            stagedFile = null; // Clear any staged file on new chat
            hideStagedFileDisplay(); // Hide the staged file display
        }
        
        function showNotification(message) {
            notificationToast.textContent = message;
            notificationToast.classList.add('show');
            notificationToast.classList.remove('hide');
            setTimeout(() => {
                notificationToast.classList.add('hide');
                notificationToast.classList.remove('show');
            }, 3000);
        }

        // Event listener for copy code button
        function handleCopyCode(event) {
            const button = event.currentTarget;
            const targetId = button.dataset.target;
            const codeElement = document.getElementById(targetId);
            if (codeElement) {
                const codeToCopy = codeElement.textContent;
                // Using document.execCommand for broader compatibility in iframes
                const textarea = document.createElement('textarea');
                textarea.value = codeToCopy;
                document.body.appendChild(textarea);
                textarea.select();
                try {
                    document.execCommand('copy');
                    showNotification('Code copied to clipboard!');
                } catch (err) {
                    console.error('Failed to copy code: ', err);
                    showNotification('Oops! Could not copy code.');
                }
                document.body.removeChild(textarea);
            }
        }

        // Event listener for download code button
        function handleDownloadCode(event) {
            const button = event.currentTarget;
            const targetId = button.dataset.target;
            let lang = button.dataset.lang || 'txt';
            const codeElement = document.getElementById(targetId);
            if (codeElement) {
                const codeToDownload = codeElement.textContent;
                
                // Map common language names to file extensions
                const fileExtension = langToFileExtension[lang.toLowerCase()] || 'txt';

                const blobType = `text/${fileExtension === 'html' || fileExtension === 'js' || fileExtension === 'css' || fileExtension === 'json' || fileExtension === 'xml' || fileExtension === 'yaml' ? fileExtension : 'plain'}`;
                
                const blob = new Blob([codeToDownload], { type: blobType });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `klai_code.${fileExtension}`; // Changed filename to klai_code
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showNotification(`Code download started as klai_code.${fileExtension}`);
            }
        }

        // Event listener for run code button (HTML only)
        function handleRunCode(event) {
            const button = event.currentTarget;
            const targetId = button.dataset.target;
            const codeElement = document.getElementById(targetId);
            if (codeElement) {
                const htmlContent = codeElement.textContent;
                const iframeDoc = codeRunnerIframe.contentWindow.document;
                iframeDoc.open();
                iframeDoc.write(htmlContent);
                iframeDoc.close();
                codeRunnerPanel.classList.remove('translate-x-full'); // Show the panel
            }
        }

        // Event Listeners
        sendBtn.addEventListener('click', sendMessage);
        userInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });
        newChatBtn.addEventListener('click', startNewChat);
        closeCodeRunnerBtn.addEventListener('click', () => {
            codeRunnerPanel.classList.add('translate-x-full'); // Hide the panel
            // Clear iframe content when closing
            codeRunnerIframe.srcdoc = ''; 
        });
        fileUploadInput.addEventListener('change', handleFileUpload);
        clearStagedFileBtn.addEventListener('click', () => {
            stagedFile = null;
            hideStagedFileDisplay();
            userInput.focus();
        });


        // Initial setup
        startNewChat(); // Call to initialize chat history and display first message
        userInput.focus();
    </script>
</body>
</html>
